import json
import re

###### File handling related functions ######

def get_raw_blocks_from_file(filename):
    """Takes the filename/path of LLVR IR .ll file. Returns raw code blocks for further processing."""
    code_blocks = []

    with open(filename, 'r') as f:
        current_block = []
        for line in f.readlines():
            line = line.replace('\n', '')

            # handle empty line = new block
            if line.strip() == '':
                if len(current_block) > 0:
                    code_blocks.append(current_block)
                    current_block = []
            else:
                current_block.append(line)
        # handle last block
        code_blocks.append(current_block)
    return code_blocks


###### LLVM code line type detection related functions ######

def is_function_start(code_line):
    return code_line.strip()[:6] == 'define'

def is_global_def(code_line):
    return code_line.strip()[0] == '@'

def is_local_def_ref(code_line):
    return code_line.strip()[0] == '!'

def is_preface(code_line):
    return code_line.strip()[:15] == 'source_filename'

def is_label(code_line, label_prefix = 'dec_label_pc_'):
    return code_line.strip()[:len(label_prefix)] == label_prefix 

def is_declaration(code_line):
    return code_line.strip()[:7] == 'declare'

def is_uselistorder(code_line):
    return code_line.strip()[:14] == '; uselistorder'

def function_ended_in_block(code_line):
    return code_line.strip() == '}'

###### Code block parsing related functions ######


def parse_code_blocks(code_blocks):
    preface = [] # meta infos
    global_block = [] # global variables
    functions = [] # local functions
    local_ref = [] # ref list at end of file
    declarations = [] # external functions

    last_block_was_function = False # to detect functions over multiple blocks
    current_function_block = [] # current function block, may include multiple blocks due to labels

    for block in code_blocks:
        first_block_line = block[0]
        last_block_line = block[-1]

        #print(is_label(block[0]), block[0])
        #continue
        # is function:
        if is_function_start(first_block_line):
            last_block_was_function = True
            current_function_block.extend(block)

            function_ended_in_current_block = function_ended_in_block(last_block_line)

            if function_ended_in_current_block:
                functions.append(current_function_block)
                current_function_block = []

        elif is_label(first_block_line):
            if last_block_was_function:
                current_function_block.extend(block)

                function_ended_in_current_block = function_ended_in_block(last_block_line)

            if function_ended_in_current_block:
                functions.append(current_function_block)
                current_function_block = []

        elif is_uselistorder(first_block_line):
            if last_block_was_function:
                current_function_block.extend(block)

                function_ended_in_current_block = function_ended_in_block(last_block_line)

            if function_ended_in_current_block:
                functions.append(current_function_block)
                current_function_block = []

        elif is_global_def(first_block_line):
            if len(global_block) == 0:
                global_block = block
            else:
                print("ERROR: Multiple global blocks identified")
                break
            last_block_was_function = False

        elif is_preface(first_block_line):
            if len(preface) == 0:
                preface = block
            else:
                print("ERROR: Multiple preface blocks identified")
                break
            last_block_was_function = False

        elif is_local_def_ref(first_block_line):
            if len(local_ref) == 0:
                local_ref = block
            else:
                print("ERROR: Multiple local ref blocks identified")
                break
            last_block_was_function = False

        elif is_declaration(first_block_line):
            pass
        else:
            print("UNKOWN BLOCK TYPE: ", first_block_line)

    return {
        'preface':preface,
        'global_block':global_block,
        'functions':functions,
        'local_ref':local_ref,
        'declarations':declarations
    }

def quick_validate_all_functions(functions):
    errors = 0
    for f in functions:
        if is_function_start(f[0]) and function_ended_in_block(f[-1]):
            pass
        else:
            print("NO VALID FUNCTION: ", f)
            errors += 1
    print(f"Validated {len(functions)} functions with {errors} errors")

###### Data structure handling ######

def extract_function_names_and_build_dictionary(functions):
    function_dict = {}
    errors = 0
    for f in functions:
        function_definition_line = f[0]
        function_name_pattern = "\@[a-zA-Z0-9_]+\("
        function_name = re.findall(function_name_pattern, function_definition_line)
        if len(function_name) == 1:
            function_name = function_name[0]
        else:
            print("Warning: Found multiple function names :", function_name)
            errors += 1
        cleaned_function_name = function_name[1:-1]
        function_dict[cleaned_function_name] = f
    print(f"Extracted {len(function_dict)} function names into dictionary with {errors} errors.")
    return function_dict

def cfg_function_list_to_cfg_function_dict(cfg_functions):
    """Takes a list of function descriptions creaded by retdec in json format
    and previously extracted from the whole configuration file. 
    Returns a dictionary that contains the same attributes with the function name as keys"""
    cfg_function_dict = {}
    for f in cfg_functions:
        f_name = f['name']
        cfg_function_dict[f_name] = f
        
    return cfg_function_dict


###### Standardization ######

def get_label_name(code_line):
    return code_line.split(':')[0].strip()

def delete_comments(code_line):
    return [l.split(';')[0].rstrip() for l in code_line]

def get_label_stats(code_line):
    labels_and_references = {}
    
    # get all label positions
    for l in code_line:
        if(is_label(l)):
            name = get_label_name(l)
            if not name in labels_and_references.keys():
                labels_and_references[name] = 0
            else:
                labels_and_references[name] += 1
    # get all label references
    for l in code_line:
        if not is_label(l):
            for lbl in labels_and_references.keys():
                if lbl in l:
                    labels_and_references[lbl] += 1
    return labels_and_references


def standardize_labels(code_lines, label_stats, drop_unused=True, mask_all=False, exclude_ref_points=False):
    """Takes code as array and label_stats from get_label_stats function.
    - Boolean drop_unused specifies if unreferenced labels should be dropped (usually at the beginning of a code block)
        doesn't affect the behaviour if exclude_ref_points is True.
    - Str mask_all specifies if all labels should be replaced with the same mask (given str) else they will be nummerated (like. LBL_0, LBL_1,...)
    - Boolean exclude_ref_points specifies if label definitions should be excluded. The Label will only remain in the branch operation."""
    
    function_code = []
    label_counter = 0
    label_prefix = 'LBL_'
    replaced_labels = {}
    
    for l in code_lines:
        if is_label(l):
            name = get_label_name(l)
            if label_stats[name] > 0 or not drop_unused:
                if not name in replaced_labels:
                    if mask_all:
                        standardized_label = mask_all # Standardize all labels !
                    else:
                        standardized_label = label_prefix + str(label_counter)
                    standardized_line = l.replace(name, standardized_label)
                    function_code.append(standardized_line)
                    replaced_labels[name] = standardized_label
                    label_counter += 1
                else:
                    standardized_label = replaced_labels[name]
                    standardized_line = l.replace(name, standardized_label)
                    function_code.append(standardized_line)
        else:
            function_code.append(l)
    
    function_code_std = []
    
    preprocessed_label = label_prefix
    if mask_all:
        preprocessed_label = mask_all
    
    for l in function_code:
        if not is_label(l, preprocessed_label):
            for lbl in replaced_labels:
                if str(lbl) in str(l):
                    #l = l.replace(lbl, replaced_labels[lbl]) # soll % vor label stehen bleiben?
                    l = l.replace(lbl, replaced_labels[lbl]) 
            function_code_std.append(l)
        else:
            if not exclude_ref_points:
                function_code_std.append(l)
            
    return function_code_std

def delete_insn_add_code(code_lines):
    """Removes !insn.addr at the end of lines."""
    cleaned_code = []
    
    for line in code_lines:
        if '!insn.addr' in line:
            line = line.split(', !insn.addr')
            if len(line) != 2:
                print(f'Error while removing "!insn.addr". Line splitted into {len(line)} parts. Line: {line}')
                return -1
            line = line[0]
            cleaned_code.append(line)
        else:
            cleaned_code.append(line)
    
    return cleaned_code
    
def standardize_function_calls(code_lines, non_local_functions=[], mask=False):
    cleaned_code = []
    function_name_pattern = "\@[a-zA-Z0-9_]*\("
    
    for line in code_lines:
        function_names = re.findall(function_name_pattern, line)
        if len(function_names) > 0:
            for f_name in function_names:
                cleaned_f_name = f_name[1:-1]
                if mask:
                    if not cleaned_f_name in non_local_functions:
                        line = line.replace(cleaned_f_name, mask)
                else:
                    print("TODO handle non mask case of function standardization")
        cleaned_code.append(line)
    return cleaned_code


def standardize_global_vars(code_lines):
    global_var_name_pattern = "\@global_var_[a-zA-Z0-9]*"
    global_vars_tracker = {} # keep track of all standardized global variables
    global_vars_tracker_ct = 0
    cleaned_code = []
    
    for line in code_lines:
        global_var_names = re.findall(global_var_name_pattern, line)
        if len(global_var_names) > 0:
            for global_var_name in global_var_names:
                # add name to dict if not exists
                if not global_var_name in global_vars_tracker:
                    global_vars_tracker[global_var_name] = "@global_var_" + str(global_vars_tracker_ct)
                    global_vars_tracker_ct += 1
                std_global_var_name = global_vars_tracker[global_var_name]
                line = line.replace(global_var_name, std_global_var_name)
        cleaned_code.append(line)
    return cleaned_code                

def standardize_stack_var(code_lines):
    global_var_name_pattern = "\%stack_var_[a-zA-Z0-9\-]*"
    global_vars_tracker = {} # keep track of all standardized global variables
    global_vars_tracker_ct = 0
    cleaned_code = []
    
    for line in code_lines:
        global_var_names = re.findall(global_var_name_pattern, line)
        if len(global_var_names) > 0:
            for global_var_name in global_var_names:
                # add name to dict if not exists
                if not global_var_name in global_vars_tracker:
                    global_vars_tracker[global_var_name] = "%stack_var_" + str(global_vars_tracker_ct)
                    global_vars_tracker_ct += 1
                std_global_var_name = global_vars_tracker[global_var_name]
                line = line.replace(global_var_name, std_global_var_name)
        cleaned_code.append(line)
    return cleaned_code  

def standardise_numbers(code_lines):
    number_pattern = "(?![a-zA-Z_@-)\d+(?![a-zA-Z_@-])" # "(?<![A-Za-z0-9_])[0-9]+" #" [0-9]+"
    cleaned_code = []
    for line in code_lines:
        numbers = re.findall(number_pattern, line)
        if len(numbers) > 0:
            for number in numbers:
                line = line.replace(number, " " + " ".join(list(number.strip())) + " ")
        cleaned_code.append(line)
    return cleaned_code
        
def standardise_numbers_from_list(tokens):
    cleaned_tokens = []
    for t in tokens:
        # handle negative numbers
        if t.lstrip('-').isdigit():
            cleaned_tokens.append("-")
            cleaned_tokens.extend(list(t.strip()))
        elif t.isdigit():
            cleaned_tokens.extend(list(t.strip()))
        else:
            cleaned_tokens.append(t)
    return cleaned_tokens
    
    
###### Lexification ######

def lexifiy_lines_as_string(code_lines, lexi_chars='(),.[]*'):
    lexi_chars = list(lexi_chars)
    cleaned_code = []

    for line in code_lines:

        for c in lexi_chars:
            line = line.replace(c, ' '+c+' ')
        
        line = ' '.join(line.split())
        # handle '...' str
        line = line.replace('. . .', '...')
        
        cleaned_code.append(line)
        
    return cleaned_code


def lexify_lines_to_list(code_lines, add_eol=False):
    lex_list = []
    
    for line in code_lines:
        lex_list.extend(line.split())
        if add_eol:
            lex_list.extend([add_eol])
    
    # remove last eol
    if add_eol:
        return lex_list[:-1]
    return lex_list


###### Function Standardization ######

def standardize_all_functions(functions, function_configs, standardize_numbers=True):
    """Takes dict of functions and corrospondign configs as dicts. 
    Returns standardized functions"""
    
    cfg_function_names = function_configs.keys()
    code_function_names = functions.keys()
    non_local_functions = [f for f in cfg_function_names if not f in code_function_names]
    lexified_functions = {}
    
    for function_name in functions:
        fct = functions[function_name]
        cfg = function_configs[function_name]
        
        lexified_function = standardize_function(fct, cfg, non_local_functions, standardize_numbers=standardize_numbers)
        #print("STANDARDIZE ", function_name)
        #print(f"LEXIFIED: ", lexified_function)
        lexified_functions[function_name] = lexified_function
        
    return lexified_functions
        
    
def standardize_function(function, function_config, non_local_functions=[], standardize_numbers=True):
    """Takes array with code lines (of one function).
    - list non_local_functions: contains strings for non local functions (which don't get standardized, like printf, memcopy etc.)
    returns array with standardized attributes(functions and variables)""" 
    
    #for f in function:
    function = delete_comments(function)
    
    label_stats = get_label_stats(function)
    
    function = standardize_labels(function, label_stats, drop_unused=True, exclude_ref_points=False)
    
    function = delete_insn_add_code(function)
    
    function = standardize_function_calls(function, non_local_functions, mask='FUNC')
    
    function = [l.replace('%LBL_', 'LBL_') for l in function]
    
    function = standardize_global_vars(function)
    
    function = standardize_stack_var(function)
    
    #lexify code
    function = lexifiy_lines_as_string(function,  lexi_chars='(),.[]*:')
    
    #if standardize_numbers:
    #    function = standardise_numbers(function)
    
    lexified_function = lexify_lines_to_list(function, add_eol='EOL')
    
    lexified_function = standardise_numbers_from_list(lexified_function)
    
    return lexified_function
        

